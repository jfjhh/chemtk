(*****************************************************************************)
(******************** BNF for a ChemTK Command Tree File. ********************)
(******************** Alex Striff                         ********************)
(*****************************************************************************)
(*                                                                           *)
(*** Purpose                                                                 *)
(*                                                                           *)
(* A ChemTK Command Tree File lays out how a command parse tree will be laid *)
(* out as a data structure under this context-free grammar. ChemTK should    *)
(* read this file and turn it's contents into the command parsing tree used  *)
(* to parse and execute ChemTK's user commands, internally.                  *)
(*                                                                           *)
(*** The Grammar                                                             *)
(*                                                                           *)
(***** An English version of the BNF below,                                  *)
(***** with added (ironic) context.                                          *)
(*                                                                           *)
(* A file is comprised of blocks, which are just chunks with optional        *)
(* comments. Chunks are either an input or a token, followed by an empty     *)
(* line. A token is made of a parent_token and optional child_tokens.        *)
(* A parent_token specifies a letter as the token (lexeme), a string as a    *)
(* name, a token input type, and an optional child_token. A child_token is   *)
(* same as a parent token, only it assumes the same input as its parent,     *)
(* has a depth to be used in constructing the tree, and an actual function   *)
(* symbol as added data. A child_token can also specify other child_tokens,  *)
(* which denote more tokens for the parent, rather than more levels of       *)
(* nesting; that is done via depth. Depth is simply a number of tabs         *)
(* prepended to a child_token. An input is a string identifier for tokens to *)
(* reference the input with, and a maximum number of characters that will be *)
(* accepted as this input type. Comments are single-line entities, delimited *)
(* by a leading pound sign ('#'). All other grammar components are not       *)
(* interesting beyond their use as elements of the other components. :P      *)
(*                                                                           *)
(*****************************************************************************)


(* Tree File. *)

<cmd_tree_file> ::= <block> <cmd_tree_file> | <EOF>
<block> ::= <comment> <chunk> | <chunk>
<chunk> ::= <input> <empty_line> | <token> <empty_line>

(* Tokens. *)

<token> ::= <parent_token> <child_token>

<parent_token> ::= <alpha> <delim> <string> <delim> <input> <EOL> <child_token>
<child_token> ::= <depth> <alpha> <delim> <string> <EOL> <child_token> | ""

<depth> ::= <TAB> <depth> | ""

(* Inputs, or numbers of characters that some token functions take.         *)
(* E.g. "symbol,4" is an input that means 4 chars are taken by any block of *)
(*      tokens with that input specified by the parent_token.               *)

<input> ::= <string> <delim> <number> <EOL>

(* Strings, numbers, letters, and the delimiter. *)

<string> ::= <alpha> <string> | ""
<alpha> ::= <uppercase_letter> | <lowercase_letter>

<number> ::= <digit> <number> | ""

<delim> ::= ','

(* Comments. *)

<comment> ::= '#' <string> <EOL>

(*****************************************************************************)

